#include <StdInc.h>
#include "Utility/InitFunction.h"
#include "Functions/Global.h"
#include "MinHook.h"
#include <Utility/Hooking.Patterns.h>
#include <thread>
#include <iostream>
#include <Windowsx.h>
#include <Utility/TouchSerial/MT6.h>
#include <iphlpapi.h>
#include <winternl.h>
#include <WinDNS.h>
#include <tlhelp32.h>
#ifdef _M_AMD64
#pragma optimize("", off)
#pragma comment(lib, "Ws2_32.lib")

extern LPCSTR hookPort;
static uintptr_t imageBase;
static unsigned char hasp_buffer[0xD40];
static bool isFreePlay;
static bool isEventMode2P;
static bool isEventMode4P;
static const char* ipaddr;

// Data for IC card, Force Feedback etc OFF.
static unsigned char settingData[405] = {
	0x1F, 0x8B, 0x08, 0x08, 0x53, 0x6A, 0x8B, 0x5A, 0x00, 0x00, 0x73, 0x65,
	0x74, 0x74, 0x69, 0x6E, 0x67, 0x2E, 0x6C, 0x75, 0x61, 0x00, 0x85, 0x93,
	0xC9, 0x6E, 0xC2, 0x30, 0x10, 0x86, 0xEF, 0x79, 0x0A, 0x5E, 0x80, 0x8A,
	0x90, 0x80, 0xE8, 0xA1, 0x07, 0x08, 0xA4, 0x20, 0x11, 0x81, 0x20, 0x2A,
	0x52, 0x6F, 0xC6, 0x19, 0x88, 0x85, 0x17, 0xE4, 0xD8, 0xAD, 0x78, 0xFB,
	0xDA, 0x59, 0x1D, 0xB5, 0x2A, 0x39, 0x44, 0xF9, 0xBF, 0x59, 0x32, 0x8B,
	0x3D, 0x1C, 0xFE, 0xFF, 0x78, 0xF6, 0x35, 0x28, 0x40, 0x29, 0xC2, 0xAF,
	0x2F, 0x54, 0x23, 0xEF, 0x49, 0xC0, 0xD0, 0xF3, 0x58, 0x84, 0x28, 0x39,
	0xAF, 0x11, 0xCF, 0x28, 0x44, 0xC0, 0x15, 0xC8, 0xC1, 0xDB, 0x20, 0x08,
	0x27, 0xD3, 0x51, 0x6D, 0x9A, 0x63, 0x0C, 0xB4, 0xB5, 0x34, 0x74, 0x21,
	0xD1, 0x0D, 0x7E, 0xD1, 0x44, 0x28, 0x21, 0x5B, 0x3A, 0xF1, 0xFD, 0x9A,
	0xA7, 0x42, 0xE3, 0x7C, 0x0B, 0x17, 0x65, 0xE8, 0x78, 0x14, 0xCE, 0x5C,
	0x7C, 0x20, 0xD7, 0xDC, 0x72, 0x3F, 0x0C, 0x82, 0xA9, 0x6B, 0x48, 0xC5,
	0xFD, 0x2F, 0xBC, 0x10, 0x4A, 0x09, 0xD6, 0x25, 0x12, 0x84, 0x47, 0xB9,
	0x56, 0x60, 0x7D, 0x3D, 0xB6, 0xD0, 0x8F, 0x08, 0xC9, 0x2C, 0x12, 0x85,
	0xCD, 0x19, 0x78, 0xEC, 0x1D, 0x31, 0xA8, 0xD5, 0xD8, 0x7A, 0x73, 0x33,
	0x1B, 0xED, 0x90, 0x58, 0x53, 0x1A, 0x09, 0x2D, 0x8B, 0x86, 0x85, 0x86,
	0x49, 0x80, 0x3D, 0x45, 0x8F, 0x2A, 0xE5, 0x1E, 0x9F, 0x37, 0x59, 0xD5,
	0xE4, 0x06, 0xDB, 0xE4, 0x87, 0x6F, 0x57, 0x7D, 0x00, 0xCF, 0x9A, 0x21,
	0x24, 0x57, 0xD7, 0x1E, 0x0B, 0x89, 0x21, 0x06, 0xC8, 0xCE, 0x08, 0xDF,
	0x2A, 0x74, 0x22, 0xBC, 0x98, 0xF3, 0xEC, 0x00, 0x0C, 0x99, 0xAF, 0x2A,
	0xFF, 0xEA, 0xCB, 0x0C, 0x2C, 0x11, 0x19, 0x54, 0x2E, 0xAD, 0x5C, 0x92,
	0xB2, 0x1E, 0x17, 0x99, 0x42, 0x79, 0x5D, 0x63, 0x44, 0x45, 0x01, 0xE9,
	0xE3, 0x0E, 0x75, 0x63, 0x56, 0x1E, 0x35, 0x37, 0xEA, 0x75, 0x5A, 0xCB,
	0x44, 0xF4, 0x64, 0xAA, 0xC1, 0x95, 0x27, 0xC8, 0x7A, 0xD6, 0x5C, 0xBB,
	0x32, 0x96, 0xC4, 0x95, 0x47, 0xA4, 0x5C, 0xB9, 0x2C, 0x67, 0x63, 0x65,
	0xB9, 0x92, 0x3D, 0xE2, 0x40, 0xAB, 0x52, 0xED, 0xB8, 0x3F, 0x84, 0x15,
	0xBE, 0x51, 0x73, 0xA5, 0x24, 0xC2, 0xAA, 0x03, 0xBB, 0xCB, 0x85, 0x12,
	0x0E, 0x5D, 0xB7, 0x26, 0x1D, 0xBE, 0x19, 0x6A, 0x0E, 0x6D, 0x05, 0x52,
	0xC2, 0xE0, 0x53, 0xF0, 0xA6, 0x35, 0xBB, 0x7B, 0x8B, 0xCC, 0x1F, 0xB7,
	0xF5, 0x41, 0x71, 0x9C, 0xD6, 0x66, 0x71, 0x6D, 0xF0, 0xAC, 0xE3, 0x09,
	0xE1, 0x6E, 0xCE, 0xA3, 0x66, 0x0C, 0xA4, 0x35, 0xF6, 0x02, 0x7A, 0x96,
	0x7E, 0xC8, 0xD3, 0x7B, 0x53, 0xDE, 0xB4, 0xD5, 0x2E, 0x7E, 0xEE, 0xF9,
	0x03, 0x44, 0x94, 0xFB, 0x8E, 0xB5, 0x03, 0x00, 0x00
};

// FOR FREEPLAY
static unsigned char terminalPackage1_Free[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x12, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0xEC, 0x72, 0x00, 0x41
};

static unsigned char terminalPackage2_Free[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x14, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xE2, 0xBA, 0xAC, 0xD4, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x99, 0x4E, 0xC6, 0x14
};

static unsigned char terminalPackage3_Free[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x19, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x89, 0x93, 0x3A, 0x22
};

static unsigned char terminalPackage4_Free[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x2E, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xF0, 0xBA, 0xAC, 0xD4, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x55, 0x42, 0x47, 0xD5
};

static unsigned char terminalPackage5_Free[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x2F, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x9C, 0xC9, 0xE0, 0x73
};

static unsigned char terminalPackage6_Free[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x6A, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x01, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xF1, 0xBA, 0xAC, 0xD4, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x26, 0xB7, 0x89, 0xD0
};

// FOR COIN ENTRY!
static unsigned char terminalPackage1_Coin[75] = {
	0x01, 0x04, 0x47, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x0B, 0x12, 0x0C, 0x32, 0x38,
	0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32, 0x18, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x09,
	0x06, 0x41, 0x0B
};

static unsigned char terminalPackage2_Coin[135] = {
	0x01, 0x04, 0x83, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x39, 0x12, 0x0C, 0x32, 0x38,
	0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32, 0x18, 0x00,
	0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04,
	0x30, 0x00, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60,
	0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88,
	0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00, 0xA0, 0x01, 0xD5, 0xBE,
	0x8F, 0xD2, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01, 0x24, 0xB8, 0x01, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xF5,
	0xF1, 0x0D, 0xB2
};

static unsigned char terminalPackage3_Coin[75] = {
	0x01, 0x04, 0x47, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x3A, 0x12, 0x0C, 0x32, 0x38,
	0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32, 0x18, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0x22,
	0x25, 0x31, 0x0D
};

static unsigned char terminalPackage4_Coin[135] = {
	0x01, 0x04, 0x83, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x00, 0x2A, 0x12, 0x08, 0x57, 0x12, 0x0C, 0x32, 0x38,
	0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32, 0x18, 0x00,
	0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04,
	0x30, 0x00, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00, 0x50, 0x02, 0x58, 0x60,
	0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60, 0x80, 0x01, 0x60, 0x88,
	0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00, 0xA0, 0x01, 0xD6, 0xBE,
	0x8F, 0xD2, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01, 0x24, 0xB8, 0x01, 0x00,
	0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00, 0x20, 0x00, 0x52, 0x0B,
	0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20, 0x00, 0x28, 0x00, 0xCA,
	0x8B, 0x15, 0xCB
};

static unsigned char terminalPackage5_Coin[79] = {
	0x01, 0x04, 0x4B, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x58, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0x3E, 0xB1, 0xB7, 0x22
};

static unsigned char terminalPackage6_Coin[139] = {
	0x01, 0x04, 0x87, 0x00, 0x12, 0x14, 0x0A, 0x00, 0x10, 0x04, 0x18, 0x00,
	0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x00, 0x1A, 0x02, 0x5A, 0x00, 0x2A, 0x12, 0x08, 0x77, 0x12, 0x0C,
	0x32, 0x38, 0x30, 0x38, 0x31, 0x31, 0x34, 0x30, 0x31, 0x35, 0x33, 0x32,
	0x18, 0x00, 0x30, 0x03, 0x42, 0x3A, 0x08, 0x01, 0x10, 0x03, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x04, 0x30, 0x00, 0x38, 0x01, 0x40, 0x00, 0x48, 0x00,
	0x50, 0x02, 0x58, 0x60, 0x60, 0x60, 0x68, 0x60, 0x70, 0x60, 0x78, 0x60,
	0x80, 0x01, 0x60, 0x88, 0x01, 0x60, 0x90, 0x01, 0x60, 0x98, 0x01, 0x00,
	0xA0, 0x01, 0xD7, 0xBE, 0x8F, 0xD2, 0x05, 0xA8, 0x01, 0x04, 0xB0, 0x01,
	0x24, 0xB8, 0x01, 0x00, 0x4A, 0x08, 0x08, 0x01, 0x10, 0x01, 0x18, 0x00,
	0x20, 0x00, 0x52, 0x0B, 0x08, 0x64, 0x10, 0xDE, 0x0F, 0x18, 0x05, 0x20,
	0x00, 0x28, 0x00, 0xBD, 0x07, 0xCF, 0xDC
};

#define HASP_STATUS_OK 0
static unsigned int Hook_hasp_login(int feature_id, void* vendor_code, int hasp_handle) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_login\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_logout(int hasp_handle) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_logout\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_encrypt(int hasp_handle, unsigned char* buffer, unsigned int buffer_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_encrypt\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_decrypt(int hasp_handle, unsigned char* buffer, unsigned int buffer_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_decrypt\n");
#endif
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_get_size(int hasp_handle, int hasp_fileid, unsigned int* hasp_size) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_get_size\n");
#endif
	* hasp_size = 0xD40; // Max addressable size by the game... absmax is 4k
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_read(int hasp_handle, int hasp_fileid, unsigned int offset, unsigned int length, unsigned char* buffer) {
#ifdef _DEBUG
	OutputDebugStringA("hasp_read\n");
#endif
	memcpy(buffer, hasp_buffer + offset, length);
	return HASP_STATUS_OK;
}

static unsigned int Hook_hasp_write(int hasp_handle, int hasp_fileid, unsigned int offset, unsigned int length, unsigned char* buffer) {
	return HASP_STATUS_OK;
}

typedef int (WINAPI* BIND)(SOCKET, CONST SOCKADDR*, INT);
static BIND pbind = NULL;

static unsigned int WINAPI Hook_bind(SOCKET s, const sockaddr* addr, int namelen) {
	sockaddr_in bindAddr = { 0 };
	bindAddr.sin_family = AF_INET;
	bindAddr.sin_addr.s_addr = inet_addr("192.168.96.20");
	bindAddr.sin_port = htons(50765);
	if (addr == (sockaddr*)&bindAddr) {
		sockaddr_in bindAddr2 = { 0 };
		bindAddr2.sin_family = AF_INET;
		bindAddr2.sin_addr.s_addr = inet_addr(ipaddr);
		bindAddr2.sin_port = htons(50765);
		return pbind(s, (sockaddr*)&bindAddr2, namelen);
	}
	else {
		return pbind(s, addr, namelen);

	}
}

static unsigned char saveData[0x2000];

static bool saveOk = false;
static unsigned char carData[0xFF];
static int SaveOk()
{
	saveOk = true;
	return 1;
}

static char carFileName[0xFF];
static bool loadOk = false;
static bool customCar = false;

static uintptr_t SaveLocation = 0x2022A68;



static uintptr_t saveGameOffset;



static BOOL FileExists(char* szPath)
{
	DWORD dwAttrib = GetFileAttributesA(szPath);

	return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
		!(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}


static int ReturnTrue()
{
	return 1;
}

static BYTE GenerateChecksum(unsigned char* myArray, int index, int length)
{
	BYTE crc = 0;
	for (int i = 0; i < length; i++)
	{
		crc += myArray[index + i];
	}
	return crc & 0xFF;
}

static void GenerateDongleData(bool isTerminal)
{
	memset(hasp_buffer, 0, 0xD40);
	hasp_buffer[0] = 0x01;
	hasp_buffer[0x13] = 0x01;
	hasp_buffer[0x17] = 0x0A;
	hasp_buffer[0x1B] = 0x04;
	hasp_buffer[0x1C] = 0x3B;
	hasp_buffer[0x1D] = 0x6B;
	hasp_buffer[0x1E] = 0x40;
	hasp_buffer[0x1F] = 0x87;

	hasp_buffer[0x23] = 0x01;
	hasp_buffer[0x27] = 0x0A;
	hasp_buffer[0x2B] = 0x04;
	hasp_buffer[0x2C] = 0x3B;
	hasp_buffer[0x2D] = 0x6B;
	hasp_buffer[0x2E] = 0x40;
	hasp_buffer[0x2F] = 0x87;
	if (isTerminal)
	{
		memcpy(hasp_buffer + 0xD00, "280811401138", 12); // not sure these are OK, since its from google lol.
		hasp_buffer[0xD3E] = GenerateChecksum(hasp_buffer, 0xD00, 62);
		hasp_buffer[0xD3F] = hasp_buffer[0xD3E] ^ 0xFF;
	}
	else
	{
		memcpy(hasp_buffer + 0xD00, "280813401138", 12);
		hasp_buffer[0xD3E] = GenerateChecksum(hasp_buffer, 0xD00, 62);
		hasp_buffer[0xD3F] = hasp_buffer[0xD3E] ^ 0xFF;
	}
}

static DWORD WINAPI SpamMulticast(LPVOID)
{
	WSADATA wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);

	SOCKET sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	int ttl = 255;
	setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ttl, sizeof(ttl));

	int reuse = 1;
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse, sizeof(reuse));

	setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&reuse, sizeof(reuse));

	sockaddr_in bindAddr = { 0 };
	bindAddr.sin_family = AF_INET;
	bindAddr.sin_addr.s_addr = inet_addr(ipaddr);
	bindAddr.sin_port = htons(50765);
	bind(sock, (sockaddr*)&bindAddr, sizeof(bindAddr));


	ip_mreq mreq;
	mreq.imr_multiaddr.s_addr = inet_addr("225.0.0.1");
	mreq.imr_interface.s_addr = inet_addr(ipaddr);

	setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mreq, sizeof(mreq));

	sockaddr_in toAddr = { 0 };
	toAddr.sin_family = AF_INET;
	toAddr.sin_addr.s_addr = inet_addr("225.0.0.1");
	toAddr.sin_port = htons(50765);

}

extern int* ffbOffset;
extern int* ffbOffset2;
extern int* ffbOffset3;
extern int* ffbOffset4;

static __int64 nbamUsbFinderRelease()
{
	return 0;
}

static __int64 nbamUsbFinderInitialize()
{
	return 0;
}

static __int64 __fastcall nbamUsbFinderGetSerialNumber(int a1, char* a2)
{
	if (ToBool(config["General"]["TerminalMode"]))
	{
		static char* serial = "280811401138";
		memcpy(a2, serial, strlen(serial));
		return 0;
	}
	else
	{
		static char* serial = "280813401138";
		memcpy(a2, serial, strlen(serial));
		return 0;
	}
}

static HWND mt6Hwnd;

typedef BOOL(WINAPI* ShowWindow_t)(HWND, int);
static ShowWindow_t pShowWindow;


// Hello Win32 my old friend...
typedef LRESULT(WINAPI* WindowProcedure_t)(HWND, UINT, WPARAM, LPARAM);
static WindowProcedure_t pMaxituneWndProc;

static BOOL gotWindowSize = FALSE;

static LRESULT Hook_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (!gotWindowSize)
	{
		mt6SetDisplayParams(hwnd);
		gotWindowSize = TRUE;
	}

	if (msg == WM_LBUTTONDOWN ||
		msg == WM_LBUTTONUP)
	{
		mt6SetTouchData(lParam, msg == WM_LBUTTONDOWN, false);
		return 0;
	}

	if (msg == WM_POINTERDOWN ||
		msg == WM_POINTERUP)
	{
		mt6SetTouchData(lParam, msg == WM_POINTERDOWN, true);
		return 0;
	}

	return pMaxituneWndProc(hwnd, msg, wParam, lParam);
}

static BOOL Hook_ShowWindow(HWND hwnd, int nCmdShow)
{
	SetWindowLongPtrW(hwnd, -4, (LONG_PTR)Hook_WndProc);
	ShowCursor(1);

	mt6Hwnd = hwnd;
	return pShowWindow(hwnd, nCmdShow);
}

DNS_STATUS(WINAPI* g_origDnsQuery_A_6R)(PCSTR pszName, WORD wType, DWORD Options, PVOID pExtra, PDNS_RECORD* ppQueryResults, PVOID* pReserved);

DNS_STATUS WINAPI DnsQuery_AHook_6R(PCSTR pszName, WORD wType, DWORD Options, PVOID pExtra, PDNS_RECORD* ppQueryResults, PVOID* pReserved)
{
#if _DEBUG
	info(true, "DnsQuery_AHook: %s", pszName);
#endif

	if (strncmp(pszName, "tenporouter.loc", 15) == 0 || strncmp(pszName, "bbrouter.loc", 15) == 0)
	{
		// TODO: make this configurable?
		const char* dnsName = config["Network"]["RouterIP"].c_str();

		return g_origDnsQuery_A_6R(dnsName, wType, Options, pExtra, ppQueryResults, pReserved);
	}
	if (strncmp(pszName, "naominet.jp", 15) == 0)
	{
		const char* serverName = config["Network"]["ServerIP"].c_str();

		return g_origDnsQuery_A_6R(serverName, wType, Options, pExtra, ppQueryResults, pReserved);
	}
	if (strncmp(pszName, "mobirouter.loc", 14) == 0 || strncmp(pszName, "dslrouter.loc", 13) == 0)
	{
#if _DEBUG
		info(true, "DnsQuery_AHooked: returning error.");
#endif
		return NULL;
	}

	return g_origDnsQuery_A_6R(pszName, wType, Options, pExtra, ppQueryResults, pReserved);
}

DNS_STATUS(WINAPI* g_origDnsQueryEx_6R)(PDNS_QUERY_REQUEST pQueryRequest, PDNS_QUERY_RESULT pQueryResults, PDNS_QUERY_CANCEL pCancelHandle);

DNS_STATUS WINAPI DnsQueryExHook_6R(PDNS_QUERY_REQUEST pQueryRequest, PDNS_QUERY_RESULT pQueryResults, PDNS_QUERY_CANCEL pCancelHandle)
{
#if _DEBUG
	//info(true, "DnsQueryEx: %s", pQueryRequest->QueryName);
#endif
	if (wcsncmp(pQueryRequest->QueryName, L"mobirouter.loc", 14) == 0)
	{
		DNS_QUERY_REQUEST QueryRequest;
		QueryRequest.Version = pQueryRequest->Version;
		QueryRequest.QueryName = L"plsfail";
		QueryRequest.QueryOptions = pQueryRequest->QueryOptions;
		QueryRequest.pDnsServerList = pQueryRequest->pDnsServerList;
		QueryRequest.InterfaceIndex = pQueryRequest->InterfaceIndex;
		QueryRequest.pQueryCompletionCallback = pQueryRequest->pQueryCompletionCallback;
		QueryRequest.pQueryContext = pQueryRequest->pQueryContext;

		return g_origDnsQueryEx_6R(&QueryRequest, pQueryResults, pCancelHandle);
	}

	if (wcsncmp(pQueryRequest->QueryName, L"tenporouter.loc", 15) == 0 || wcsncmp(pQueryRequest->QueryName, L"bbrouter.loc", 15) == 0)
	{
		// TODO: make it configurable? Add check for other common sega stuff?
		wchar_t* wString = new wchar_t[4096];
		MultiByteToWideChar(CP_ACP, 0, config["Network"]["RouterIP"].c_str(), -1, wString, 4096);
		DNS_QUERY_REQUEST QueryRequest;
		QueryRequest.Version = pQueryRequest->Version;
		QueryRequest.QueryName = wString;
		QueryRequest.QueryOptions = pQueryRequest->QueryOptions;
		QueryRequest.pDnsServerList = pQueryRequest->pDnsServerList;
		QueryRequest.InterfaceIndex = pQueryRequest->InterfaceIndex;
		QueryRequest.pQueryCompletionCallback = pQueryRequest->pQueryCompletionCallback;
		QueryRequest.pQueryContext = pQueryRequest->pQueryContext;

		return g_origDnsQueryEx_6R(&QueryRequest, pQueryResults, pCancelHandle);
	}

	return g_origDnsQueryEx_6R(pQueryRequest, pQueryResults, pCancelHandle);
}

int(WSAAPI* g_origInetPtonW_6R)(INT Family, PCWSTR pszAddrString, PVOID pAddrBuf);

int WSAAPI InetPtonWHook_6R(INT Family, PCWSTR pszAddrString, PVOID pAddrBuf)
{
#if _DEBUG
	//infoW(true, L"InetPtonWHook: %s", pszAddrString);
#endif
	// idk yet if this is also needed or not.
	//if (wcsncmp(pszAddrString, L"tenporouter.loc", 15) == 0)
	//{
	//	return g_origInetPtonW_6R(Family, L"localhost", pAddrBuf);
	//}
	//if (wcsncmp(pszAddrString, L"mobirouter.loc", 15) == 0) 
	//{
	//	return g_origInetPtonW_6R(Family, L"plsfail", pAddrBuf);
	//}

	return g_origInetPtonW_6R(Family, pszAddrString, pAddrBuf);
}

int(WSAAPI* g_origgetaddrinfo_6R)(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult);

int WSAAPI getaddrinfoHook_6R(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult)
{
#if _DEBUG
	info(true, "getaddrinfo: %s, %s", pNodeName, pServiceName);
#endif

	return g_origgetaddrinfo_6R(pNodeName, pServiceName, pHints, ppResult);
}

// array size is 1107
static const unsigned char terminal_cert_v388[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49,
  0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x44,
  0x42, 0x44, 0x43, 0x43, 0x41, 0x6d, 0x32, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x55,
  0x47, 0x73, 0x75, 0x41, 0x30, 0x53, 0x50, 0x37, 0x66, 0x63, 0x45, 0x73, 0x53, 0x31, 0x4e, 0x5a,
  0x63, 0x46, 0x70, 0x4f, 0x6b, 0x30, 0x59, 0x72, 0x50, 0x7a, 0x67, 0x77, 0x44, 0x51, 0x59, 0x4a,
  0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x46, 0x0a, 0x42, 0x51, 0x41,
  0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59,
  0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34, 0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74, 0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77, 0x58, 0x54, 0x6b, 0x46, 0x4e, 0x0a, 0x51, 0x30,
  0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46, 0x4a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57,
  0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79, 0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67,
  0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55, 0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d,
  0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d, 0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x0a, 0x63,
  0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e, 0x51, 0x78, 0x4c, 0x54, 0x41, 0x72, 0x42,
  0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a, 0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49,
  0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53, 0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63,
  0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c, 0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x0a,
  0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64, 0x44, 0x41, 0x67, 0x46, 0x77, 0x30, 0x79,
  0x4d, 0x54, 0x41, 0x33, 0x4d, 0x54, 0x67, 0x78, 0x4f, 0x44, 0x55, 0x35, 0x4d, 0x54, 0x42, 0x61,
  0x47, 0x41, 0x38, 0x7a, 0x4d, 0x44, 0x41, 0x78, 0x4d, 0x44, 0x6b, 0x78, 0x4f, 0x54, 0x45, 0x34,
  0x4e, 0x54, 0x6b, 0x78, 0x4d, 0x46, 0x6f, 0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a,
  0x0a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34,
  0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74,
  0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77,
  0x58, 0x54, 0x6b, 0x46, 0x4e, 0x51, 0x30, 0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46,
  0x4a, 0x0a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57, 0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79,
  0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55,
  0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d, 0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d,
  0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x63, 0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e,
  0x51, 0x78, 0x0a, 0x4c, 0x54, 0x41, 0x72, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a,
  0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49, 0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53,
  0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63, 0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c,
  0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64,
  0x44, 0x43, 0x42, 0x0a, 0x6e, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x42, 0x6a, 0x51, 0x41, 0x77,
  0x67, 0x59, 0x6b, 0x43, 0x67, 0x59, 0x45, 0x41, 0x33, 0x47, 0x54, 0x4f, 0x41, 0x2f, 0x4a, 0x31,
  0x62, 0x69, 0x41, 0x6e, 0x71, 0x6c, 0x79, 0x70, 0x33, 0x36, 0x43, 0x55, 0x77, 0x55, 0x35, 0x42,
  0x63, 0x64, 0x63, 0x71, 0x0a, 0x39, 0x37, 0x4d, 0x61, 0x54, 0x77, 0x37, 0x68, 0x4d, 0x55, 0x66,
  0x54, 0x71, 0x58, 0x57, 0x33, 0x32, 0x35, 0x33, 0x69, 0x71, 0x48, 0x4b, 0x33, 0x50, 0x72, 0x68,
  0x58, 0x78, 0x45, 0x78, 0x7a, 0x39, 0x4a, 0x37, 0x6e, 0x70, 0x79, 0x2b, 0x31, 0x34, 0x36, 0x76,
  0x31, 0x75, 0x38, 0x4c, 0x33, 0x4e, 0x70, 0x66, 0x41, 0x48, 0x44, 0x58, 0x37, 0x45, 0x57, 0x6c,
  0x4c, 0x48, 0x51, 0x58, 0x57, 0x0a, 0x6b, 0x4e, 0x6f, 0x49, 0x37, 0x4a, 0x6b, 0x56, 0x56, 0x59,
  0x73, 0x32, 0x35, 0x66, 0x71, 0x58, 0x4c, 0x41, 0x4b, 0x79, 0x49, 0x4a, 0x4a, 0x4f, 0x42, 0x48,
  0x52, 0x43, 0x66, 0x46, 0x4f, 0x38, 0x50, 0x46, 0x79, 0x35, 0x32, 0x51, 0x53, 0x4c, 0x5a, 0x53,
  0x70, 0x7a, 0x55, 0x63, 0x68, 0x58, 0x4b, 0x61, 0x75, 0x73, 0x79, 0x79, 0x45, 0x6b, 0x32, 0x44,
  0x78, 0x70, 0x2f, 0x78, 0x61, 0x69, 0x0a, 0x65, 0x49, 0x64, 0x69, 0x68, 0x50, 0x76, 0x37, 0x49,
  0x55, 0x50, 0x6e, 0x70, 0x64, 0x30, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4e, 0x54, 0x4d,
  0x46, 0x45, 0x77, 0x48, 0x51, 0x59, 0x44, 0x56, 0x52, 0x30, 0x4f, 0x42, 0x42, 0x59, 0x45, 0x46,
  0x45, 0x77, 0x37, 0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35,
  0x32, 0x64, 0x33, 0x66, 0x64, 0x70, 0x62, 0x0a, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x42, 0x38, 0x47,
  0x41, 0x31, 0x55, 0x64, 0x49, 0x77, 0x51, 0x59, 0x4d, 0x42, 0x61, 0x41, 0x46, 0x45, 0x77, 0x37,
  0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35, 0x32, 0x64, 0x33,
  0x66, 0x64, 0x70, 0x62, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x41, 0x38, 0x47, 0x41, 0x31, 0x55, 0x64,
  0x45, 0x77, 0x51, 0x49, 0x4d, 0x41, 0x59, 0x42, 0x0a, 0x41, 0x66, 0x38, 0x43, 0x41, 0x51, 0x41,
  0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45,
  0x46, 0x42, 0x51, 0x41, 0x44, 0x67, 0x59, 0x45, 0x41, 0x58, 0x46, 0x4c, 0x73, 0x70, 0x52, 0x47,
  0x67, 0x2b, 0x53, 0x4b, 0x73, 0x6f, 0x44, 0x33, 0x72, 0x48, 0x4c, 0x68, 0x47, 0x32, 0x31, 0x2f,
  0x74, 0x31, 0x64, 0x64, 0x6b, 0x6b, 0x4e, 0x70, 0x54, 0x0a, 0x78, 0x56, 0x4d, 0x31, 0x66, 0x4b,
  0x61, 0x33, 0x6a, 0x45, 0x45, 0x35, 0x7a, 0x62, 0x6d, 0x6d, 0x4a, 0x74, 0x67, 0x4e, 0x51, 0x47,
  0x33, 0x68, 0x59, 0x41, 0x77, 0x69, 0x2f, 0x71, 0x6e, 0x77, 0x57, 0x72, 0x34, 0x39, 0x55, 0x6d,
  0x41, 0x57, 0x49, 0x68, 0x5a, 0x7a, 0x43, 0x43, 0x44, 0x51, 0x53, 0x2f, 0x62, 0x30, 0x65, 0x31,
  0x32, 0x6c, 0x5a, 0x2b, 0x6e, 0x65, 0x33, 0x32, 0x77, 0x4b, 0x0a, 0x4e, 0x45, 0x2b, 0x73, 0x35,
  0x6c, 0x31, 0x53, 0x71, 0x52, 0x41, 0x51, 0x46, 0x36, 0x4e, 0x68, 0x75, 0x4f, 0x35, 0x4d, 0x37,
  0x6d, 0x51, 0x32, 0x4a, 0x47, 0x38, 0x69, 0x6e, 0x48, 0x6e, 0x4e, 0x34, 0x59, 0x77, 0x70, 0x72,
  0x66, 0x74, 0x45, 0x6f, 0x67, 0x76, 0x52, 0x2f, 0x69, 0x7a, 0x65, 0x61, 0x6b, 0x35, 0x4d, 0x4d,
  0x7a, 0x43, 0x77, 0x36, 0x34, 0x44, 0x66, 0x44, 0x43, 0x79, 0x41, 0x0a, 0x6d, 0x72, 0x4a, 0x6f,
  0x71, 0x77, 0x75, 0x71, 0x69, 0x74, 0x34, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e,
  0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a
};

// array size is 1107
static const unsigned char v388_ca_cert[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49,
  0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x44,
  0x42, 0x44, 0x43, 0x43, 0x41, 0x6d, 0x32, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x55,
  0x47, 0x73, 0x75, 0x41, 0x30, 0x53, 0x50, 0x37, 0x66, 0x63, 0x45, 0x73, 0x53, 0x31, 0x4e, 0x5a,
  0x63, 0x46, 0x70, 0x4f, 0x6b, 0x30, 0x59, 0x72, 0x50, 0x7a, 0x67, 0x77, 0x44, 0x51, 0x59, 0x4a,
  0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x46, 0x0a, 0x42, 0x51, 0x41,
  0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59,
  0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34, 0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51,
  0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74, 0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34,
  0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77, 0x58, 0x54, 0x6b, 0x46, 0x4e, 0x0a, 0x51, 0x30,
  0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46, 0x4a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57,
  0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79, 0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67,
  0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55, 0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d,
  0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d, 0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x0a, 0x63,
  0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e, 0x51, 0x78, 0x4c, 0x54, 0x41, 0x72, 0x42,
  0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a, 0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49,
  0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53, 0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63,
  0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c, 0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x0a,
  0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64, 0x44, 0x41, 0x67, 0x46, 0x77, 0x30, 0x79,
  0x4d, 0x54, 0x41, 0x33, 0x4d, 0x54, 0x67, 0x78, 0x4f, 0x44, 0x55, 0x35, 0x4d, 0x54, 0x42, 0x61,
  0x47, 0x41, 0x38, 0x7a, 0x4d, 0x44, 0x41, 0x78, 0x4d, 0x44, 0x6b, 0x78, 0x4f, 0x54, 0x45, 0x34,
  0x4e, 0x54, 0x6b, 0x78, 0x4d, 0x46, 0x6f, 0x77, 0x67, 0x5a, 0x49, 0x78, 0x43, 0x7a, 0x41, 0x4a,
  0x0a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x70, 0x51, 0x4d, 0x51, 0x34,
  0x77, 0x44, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x49, 0x44, 0x41, 0x56, 0x55, 0x62, 0x32, 0x74,
  0x35, 0x62, 0x7a, 0x45, 0x67, 0x4d, 0x42, 0x34, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x67, 0x77,
  0x58, 0x54, 0x6b, 0x46, 0x4e, 0x51, 0x30, 0x38, 0x67, 0x51, 0x6b, 0x46, 0x4f, 0x52, 0x45, 0x46,
  0x4a, 0x0a, 0x49, 0x45, 0x64, 0x68, 0x62, 0x57, 0x56, 0x7a, 0x49, 0x45, 0x6c, 0x75, 0x59, 0x79,
  0x34, 0x78, 0x49, 0x6a, 0x41, 0x67, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x73, 0x4d, 0x47, 0x55,
  0x35, 0x6c, 0x64, 0x48, 0x64, 0x76, 0x63, 0x6d, 0x73, 0x67, 0x55, 0x32, 0x56, 0x79, 0x64, 0x6d,
  0x56, 0x79, 0x49, 0x45, 0x52, 0x6c, 0x63, 0x47, 0x46, 0x79, 0x64, 0x47, 0x31, 0x6c, 0x62, 0x6e,
  0x51, 0x78, 0x0a, 0x4c, 0x54, 0x41, 0x72, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x4d, 0x4a,
  0x45, 0x35, 0x42, 0x54, 0x55, 0x4e, 0x50, 0x49, 0x45, 0x4a, 0x42, 0x54, 0x6b, 0x52, 0x42, 0x53,
  0x53, 0x42, 0x48, 0x59, 0x57, 0x31, 0x6c, 0x63, 0x79, 0x42, 0x4a, 0x62, 0x6d, 0x4d, 0x67, 0x4c,
  0x53, 0x42, 0x4f, 0x55, 0x30, 0x51, 0x67, 0x51, 0x30, 0x45, 0x67, 0x55, 0x6d, 0x39, 0x76, 0x64,
  0x44, 0x43, 0x42, 0x0a, 0x6e, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x42, 0x6a, 0x51, 0x41, 0x77,
  0x67, 0x59, 0x6b, 0x43, 0x67, 0x59, 0x45, 0x41, 0x33, 0x47, 0x54, 0x4f, 0x41, 0x2f, 0x4a, 0x31,
  0x62, 0x69, 0x41, 0x6e, 0x71, 0x6c, 0x79, 0x70, 0x33, 0x36, 0x43, 0x55, 0x77, 0x55, 0x35, 0x42,
  0x63, 0x64, 0x63, 0x71, 0x0a, 0x39, 0x37, 0x4d, 0x61, 0x54, 0x77, 0x37, 0x68, 0x4d, 0x55, 0x66,
  0x54, 0x71, 0x58, 0x57, 0x33, 0x32, 0x35, 0x33, 0x69, 0x71, 0x48, 0x4b, 0x33, 0x50, 0x72, 0x68,
  0x58, 0x78, 0x45, 0x78, 0x7a, 0x39, 0x4a, 0x37, 0x6e, 0x70, 0x79, 0x2b, 0x31, 0x34, 0x36, 0x76,
  0x31, 0x75, 0x38, 0x4c, 0x33, 0x4e, 0x70, 0x66, 0x41, 0x48, 0x44, 0x58, 0x37, 0x45, 0x57, 0x6c,
  0x4c, 0x48, 0x51, 0x58, 0x57, 0x0a, 0x6b, 0x4e, 0x6f, 0x49, 0x37, 0x4a, 0x6b, 0x56, 0x56, 0x59,
  0x73, 0x32, 0x35, 0x66, 0x71, 0x58, 0x4c, 0x41, 0x4b, 0x79, 0x49, 0x4a, 0x4a, 0x4f, 0x42, 0x48,
  0x52, 0x43, 0x66, 0x46, 0x4f, 0x38, 0x50, 0x46, 0x79, 0x35, 0x32, 0x51, 0x53, 0x4c, 0x5a, 0x53,
  0x70, 0x7a, 0x55, 0x63, 0x68, 0x58, 0x4b, 0x61, 0x75, 0x73, 0x79, 0x79, 0x45, 0x6b, 0x32, 0x44,
  0x78, 0x70, 0x2f, 0x78, 0x61, 0x69, 0x0a, 0x65, 0x49, 0x64, 0x69, 0x68, 0x50, 0x76, 0x37, 0x49,
  0x55, 0x50, 0x6e, 0x70, 0x64, 0x30, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4e, 0x54, 0x4d,
  0x46, 0x45, 0x77, 0x48, 0x51, 0x59, 0x44, 0x56, 0x52, 0x30, 0x4f, 0x42, 0x42, 0x59, 0x45, 0x46,
  0x45, 0x77, 0x37, 0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35,
  0x32, 0x64, 0x33, 0x66, 0x64, 0x70, 0x62, 0x0a, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x42, 0x38, 0x47,
  0x41, 0x31, 0x55, 0x64, 0x49, 0x77, 0x51, 0x59, 0x4d, 0x42, 0x61, 0x41, 0x46, 0x45, 0x77, 0x37,
  0x67, 0x4b, 0x32, 0x4c, 0x34, 0x48, 0x2f, 0x79, 0x31, 0x52, 0x4a, 0x67, 0x35, 0x32, 0x64, 0x33,
  0x66, 0x64, 0x70, 0x62, 0x78, 0x6c, 0x71, 0x4a, 0x4d, 0x41, 0x38, 0x47, 0x41, 0x31, 0x55, 0x64,
  0x45, 0x77, 0x51, 0x49, 0x4d, 0x41, 0x59, 0x42, 0x0a, 0x41, 0x66, 0x38, 0x43, 0x41, 0x51, 0x41,
  0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45,
  0x46, 0x42, 0x51, 0x41, 0x44, 0x67, 0x59, 0x45, 0x41, 0x58, 0x46, 0x4c, 0x73, 0x70, 0x52, 0x47,
  0x67, 0x2b, 0x53, 0x4b, 0x73, 0x6f, 0x44, 0x33, 0x72, 0x48, 0x4c, 0x68, 0x47, 0x32, 0x31, 0x2f,
  0x74, 0x31, 0x64, 0x64, 0x6b, 0x6b, 0x4e, 0x70, 0x54, 0x0a, 0x78, 0x56, 0x4d, 0x31, 0x66, 0x4b,
  0x61, 0x33, 0x6a, 0x45, 0x45, 0x35, 0x7a, 0x62, 0x6d, 0x6d, 0x4a, 0x74, 0x67, 0x4e, 0x51, 0x47,
  0x33, 0x68, 0x59, 0x41, 0x77, 0x69, 0x2f, 0x71, 0x6e, 0x77, 0x57, 0x72, 0x34, 0x39, 0x55, 0x6d,
  0x41, 0x57, 0x49, 0x68, 0x5a, 0x7a, 0x43, 0x43, 0x44, 0x51, 0x53, 0x2f, 0x62, 0x30, 0x65, 0x31,
  0x32, 0x6c, 0x5a, 0x2b, 0x6e, 0x65, 0x33, 0x32, 0x77, 0x4b, 0x0a, 0x4e, 0x45, 0x2b, 0x73, 0x35,
  0x6c, 0x31, 0x53, 0x71, 0x52, 0x41, 0x51, 0x46, 0x36, 0x4e, 0x68, 0x75, 0x4f, 0x35, 0x4d, 0x37,
  0x6d, 0x51, 0x32, 0x4a, 0x47, 0x38, 0x69, 0x6e, 0x48, 0x6e, 0x4e, 0x34, 0x59, 0x77, 0x70, 0x72,
  0x66, 0x74, 0x45, 0x6f, 0x67, 0x76, 0x52, 0x2f, 0x69, 0x7a, 0x65, 0x61, 0x6b, 0x35, 0x4d, 0x4d,
  0x7a, 0x43, 0x77, 0x36, 0x34, 0x44, 0x66, 0x44, 0x43, 0x79, 0x41, 0x0a, 0x6d, 0x72, 0x4a, 0x6f,
  0x71, 0x77, 0x75, 0x71, 0x69, 0x74, 0x34, 0x3d, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e,
  0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a
};

// array size is 912
static const unsigned char terminal_key_v388[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41,
  0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x43,
  0x64, 0x51, 0x49, 0x42, 0x41, 0x44, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47,
  0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x45, 0x46, 0x41, 0x41, 0x53, 0x43, 0x41, 0x6c, 0x38, 0x77,
  0x67, 0x67, 0x4a, 0x62, 0x41, 0x67, 0x45, 0x41, 0x41, 0x6f, 0x47, 0x42, 0x41, 0x4e, 0x78, 0x6b,
  0x7a, 0x67, 0x50, 0x79, 0x64, 0x57, 0x34, 0x67, 0x4a, 0x36, 0x70, 0x63, 0x0a, 0x71, 0x64, 0x2b,
  0x67, 0x6c, 0x4d, 0x46, 0x4f, 0x51, 0x58, 0x48, 0x58, 0x4b, 0x76, 0x65, 0x7a, 0x47, 0x6b, 0x38,
  0x4f, 0x34, 0x54, 0x46, 0x48, 0x30, 0x36, 0x6c, 0x31, 0x74, 0x39, 0x75, 0x64, 0x34, 0x71, 0x68,
  0x79, 0x74, 0x7a, 0x36, 0x34, 0x56, 0x38, 0x52, 0x4d, 0x63, 0x2f, 0x53, 0x65, 0x35, 0x36, 0x63,
  0x76, 0x74, 0x65, 0x4f, 0x72, 0x39, 0x62, 0x76, 0x43, 0x39, 0x7a, 0x61, 0x58, 0x0a, 0x77, 0x42,
  0x77, 0x31, 0x2b, 0x78, 0x46, 0x70, 0x53, 0x78, 0x30, 0x46, 0x31, 0x70, 0x44, 0x61, 0x43, 0x4f,
  0x79, 0x5a, 0x46, 0x56, 0x57, 0x4c, 0x4e, 0x75, 0x58, 0x36, 0x6c, 0x79, 0x77, 0x43, 0x73, 0x69,
  0x43, 0x53, 0x54, 0x67, 0x52, 0x30, 0x51, 0x6e, 0x78, 0x54, 0x76, 0x44, 0x78, 0x63, 0x75, 0x64,
  0x6b, 0x45, 0x69, 0x32, 0x55, 0x71, 0x63, 0x31, 0x48, 0x49, 0x56, 0x79, 0x6d, 0x72, 0x0a, 0x72,
  0x4d, 0x73, 0x68, 0x4a, 0x4e, 0x67, 0x38, 0x61, 0x66, 0x38, 0x57, 0x6f, 0x6e, 0x69, 0x48, 0x59,
  0x6f, 0x54, 0x37, 0x2b, 0x79, 0x46, 0x44, 0x35, 0x36, 0x58, 0x64, 0x41, 0x67, 0x4d, 0x42, 0x41,
  0x41, 0x45, 0x43, 0x67, 0x59, 0x42, 0x32, 0x38, 0x53, 0x78, 0x42, 0x38, 0x78, 0x4d, 0x76, 0x47,
  0x4d, 0x6c, 0x76, 0x5a, 0x73, 0x30, 0x43, 0x39, 0x46, 0x33, 0x7a, 0x71, 0x54, 0x45, 0x6d, 0x0a,
  0x71, 0x42, 0x48, 0x33, 0x56, 0x6b, 0x43, 0x48, 0x6c, 0x43, 0x63, 0x79, 0x65, 0x6d, 0x6f, 0x66,
  0x31, 0x58, 0x6b, 0x68, 0x58, 0x43, 0x63, 0x62, 0x38, 0x37, 0x55, 0x7a, 0x63, 0x7a, 0x64, 0x69,
  0x71, 0x45, 0x51, 0x59, 0x4b, 0x37, 0x34, 0x6e, 0x65, 0x31, 0x63, 0x31, 0x68, 0x50, 0x4e, 0x38,
  0x6e, 0x71, 0x37, 0x65, 0x56, 0x71, 0x32, 0x47, 0x54, 0x42, 0x65, 0x76, 0x67, 0x41, 0x31, 0x7a,
  0x0a, 0x79, 0x38, 0x4f, 0x49, 0x31, 0x33, 0x64, 0x6c, 0x51, 0x75, 0x30, 0x6f, 0x71, 0x5a, 0x4c,
  0x41, 0x65, 0x70, 0x43, 0x6f, 0x2b, 0x78, 0x4d, 0x38, 0x6a, 0x66, 0x56, 0x66, 0x55, 0x4a, 0x6b,
  0x30, 0x35, 0x74, 0x64, 0x42, 0x76, 0x65, 0x64, 0x4e, 0x70, 0x4c, 0x58, 0x6d, 0x55, 0x6f, 0x6a,
  0x36, 0x7a, 0x4b, 0x74, 0x63, 0x45, 0x75, 0x57, 0x6d, 0x4c, 0x75, 0x55, 0x53, 0x2f, 0x31, 0x4f,
  0x45, 0x0a, 0x72, 0x59, 0x56, 0x58, 0x62, 0x71, 0x35, 0x58, 0x70, 0x4a, 0x65, 0x4d, 0x62, 0x59,
  0x4f, 0x54, 0x34, 0x51, 0x4a, 0x42, 0x41, 0x50, 0x75, 0x63, 0x59, 0x63, 0x43, 0x52, 0x39, 0x32,
  0x46, 0x45, 0x71, 0x46, 0x4e, 0x74, 0x78, 0x56, 0x78, 0x4f, 0x50, 0x79, 0x59, 0x53, 0x63, 0x53,
  0x2f, 0x7a, 0x44, 0x70, 0x6e, 0x54, 0x41, 0x6c, 0x49, 0x59, 0x38, 0x44, 0x45, 0x6b, 0x51, 0x4d,
  0x74, 0x39, 0x0a, 0x79, 0x5a, 0x39, 0x32, 0x6c, 0x79, 0x2f, 0x78, 0x66, 0x72, 0x6a, 0x42, 0x31,
  0x4e, 0x52, 0x73, 0x57, 0x6c, 0x7a, 0x79, 0x4d, 0x75, 0x69, 0x66, 0x6c, 0x2b, 0x53, 0x68, 0x5a,
  0x32, 0x30, 0x36, 0x2f, 0x63, 0x4b, 0x5a, 0x79, 0x67, 0x38, 0x4e, 0x75, 0x4c, 0x6b, 0x43, 0x51,
  0x51, 0x44, 0x67, 0x50, 0x51, 0x52, 0x4b, 0x2f, 0x34, 0x42, 0x62, 0x49, 0x42, 0x79, 0x42, 0x47,
  0x71, 0x2b, 0x72, 0x0a, 0x6e, 0x62, 0x73, 0x6a, 0x4f, 0x76, 0x2f, 0x79, 0x70, 0x48, 0x36, 0x36,
  0x49, 0x44, 0x68, 0x73, 0x2f, 0x42, 0x62, 0x62, 0x6e, 0x42, 0x55, 0x59, 0x4d, 0x59, 0x2b, 0x6b,
  0x2b, 0x7a, 0x38, 0x2f, 0x37, 0x6e, 0x34, 0x32, 0x62, 0x61, 0x74, 0x4e, 0x79, 0x47, 0x66, 0x43,
  0x4a, 0x36, 0x55, 0x56, 0x35, 0x76, 0x62, 0x52, 0x64, 0x73, 0x47, 0x7a, 0x6a, 0x73, 0x61, 0x4f,
  0x6b, 0x65, 0x44, 0x64, 0x0a, 0x64, 0x62, 0x78, 0x46, 0x41, 0x6b, 0x41, 0x65, 0x77, 0x59, 0x66,
  0x6c, 0x62, 0x54, 0x4a, 0x4c, 0x44, 0x6f, 0x52, 0x77, 0x35, 0x6b, 0x73, 0x6f, 0x74, 0x46, 0x76,
  0x64, 0x77, 0x49, 0x56, 0x62, 0x63, 0x68, 0x2b, 0x48, 0x79, 0x42, 0x5a, 0x52, 0x69, 0x4d, 0x44,
  0x62, 0x6b, 0x4f, 0x33, 0x6d, 0x73, 0x66, 0x4b, 0x53, 0x62, 0x6f, 0x47, 0x65, 0x6c, 0x36, 0x75,
  0x41, 0x31, 0x42, 0x69, 0x36, 0x0a, 0x2b, 0x70, 0x2b, 0x31, 0x47, 0x74, 0x6f, 0x45, 0x4f, 0x33,
  0x58, 0x71, 0x75, 0x5a, 0x77, 0x56, 0x36, 0x77, 0x38, 0x58, 0x32, 0x59, 0x71, 0x73, 0x65, 0x6d,
  0x58, 0x70, 0x41, 0x6b, 0x41, 0x4c, 0x39, 0x78, 0x57, 0x49, 0x6a, 0x76, 0x4f, 0x68, 0x61, 0x53,
  0x67, 0x38, 0x4e, 0x31, 0x6c, 0x53, 0x56, 0x66, 0x74, 0x4c, 0x57, 0x50, 0x57, 0x5a, 0x55, 0x2b,
  0x2b, 0x7a, 0x4c, 0x4d, 0x37, 0x31, 0x0a, 0x2b, 0x63, 0x6d, 0x61, 0x64, 0x45, 0x79, 0x6e, 0x32,
  0x74, 0x55, 0x6f, 0x58, 0x34, 0x4f, 0x7a, 0x66, 0x4a, 0x31, 0x64, 0x65, 0x43, 0x4b, 0x67, 0x35,
  0x75, 0x57, 0x71, 0x64, 0x59, 0x55, 0x59, 0x6b, 0x78, 0x64, 0x75, 0x65, 0x2b, 0x44, 0x41, 0x48,
  0x51, 0x6b, 0x35, 0x53, 0x45, 0x31, 0x77, 0x59, 0x37, 0x7a, 0x6c, 0x41, 0x6b, 0x42, 0x47, 0x37,
  0x67, 0x4e, 0x71, 0x74, 0x78, 0x35, 0x30, 0x0a, 0x38, 0x4a, 0x4d, 0x61, 0x44, 0x4b, 0x71, 0x6d,
  0x46, 0x6c, 0x62, 0x33, 0x56, 0x46, 0x42, 0x47, 0x52, 0x34, 0x58, 0x54, 0x53, 0x77, 0x70, 0x75,
  0x48, 0x31, 0x4f, 0x38, 0x66, 0x37, 0x74, 0x62, 0x5a, 0x4a, 0x76, 0x74, 0x4b, 0x5a, 0x36, 0x56,
  0x56, 0x65, 0x4b, 0x58, 0x2b, 0x2b, 0x6b, 0x41, 0x2b, 0x62, 0x70, 0x41, 0x59, 0x4b, 0x76, 0x41,
  0x58, 0x45, 0x43, 0x34, 0x38, 0x6b, 0x39, 0x77, 0x0a, 0x58, 0x6f, 0x59, 0x64, 0x57, 0x48, 0x56,
  0x79, 0x62, 0x4e, 0x68, 0x38, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x50,
  0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a
};

static void prepareCerts()
{
	// data_jp/network/certs
	FILE* file2 = fopen("./data_jp/network/certs/terminal-cert_v388.pem", "wb");
	fwrite(terminal_cert_v388, 1, sizeof(terminal_cert_v388), file2);
	fclose(file2);

	// data_jp/network/certs
	FILE* cacert = fopen("./data_jp/network/certs/v388-ca-cert.pem", "wb");
	fwrite(v388_ca_cert, 1, sizeof(v388_ca_cert), cacert);
	fclose(cacert);

	// data_jp/network/private
	FILE* termkey = fopen("./data_jp/network/private/terminal-key_v388.pem", "wb");
	fwrite(terminal_key_v388, 1, sizeof(terminal_key_v388), termkey);
	fclose(termkey);
	return;
}

static InitFunction Wmmt6RFunc([]()
{
	// Alloc debug console
	FreeConsole();
	AllocConsole();
	SetConsoleTitle(L"Maxitune6R Console");

	FILE* pNewStdout = nullptr;
	FILE* pNewStderr = nullptr;
	FILE* pNewStdin = nullptr;

	::freopen_s(&pNewStdout, "CONOUT$", "w", stdout);
	::freopen_s(&pNewStderr, "CONOUT$", "w", stderr);
	::freopen_s(&pNewStdin, "CONIN$", "r", stdin);
	std::cout.clear();
	std::cerr.clear();
	std::cin.clear();
	std::wcout.clear();
	std::wcerr.clear();
	std::wcin.clear();

	puts("hello there, maxitune");

	Sleep(2000); // delay to make sure amauth running first

	// folder for path redirections
	prepareCerts();
	CreateDirectoryA(".\\TP", nullptr);

	FILE* fileF = _wfopen(L".\\TP\\setting.lua.gz", L"r");
	if (fileF == NULL)
	{
		FILE* settingsF = _wfopen(L".\\TP\\setting.lua.gz", L"wb");
		fwrite(settingData, 1, sizeof(settingData), settingsF);
		fclose(settingsF);
	}
	else
	{
		fclose(fileF);
	}

	bool isTerminal = false;
	if (ToBool(config["General"]["TerminalMode"]))
	{
		isTerminal = true;
	}

	std::string networkip = config["General"]["NetworkAdapterIP"];
	if (!networkip.empty())
	{
		ipaddr = networkip.c_str();
	}

	hookPort = "COM3";
	imageBase = (uintptr_t)GetModuleHandleA(0);
	MH_Initialize();

	// Hook dongle funcs
	MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_write", Hook_hasp_write, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_read", Hook_hasp_read, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_get_size", Hook_hasp_get_size, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_decrypt", Hook_hasp_decrypt, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_encrypt", Hook_hasp_encrypt, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_logout", Hook_hasp_logout, NULL);
	MH_CreateHookApi(L"hasp_windows_x64_28756.dll", "hasp_login", Hook_hasp_login, NULL);
	MH_CreateHookApi(L"nbamUsbFinder.dll", "nbamUsbFinderGetSerialNumber", nbamUsbFinderGetSerialNumber, NULL);
	MH_CreateHookApi(L"nbamUsbFinder.dll", "nbamUsbFinderInitialize", nbamUsbFinderInitialize, NULL);
	MH_CreateHookApi(L"nbamUsbFinder.dll", "nbamUsbFinderRelease", nbamUsbFinderRelease, NULL);

	MH_CreateHookApi(L"WS2_32", "bind", Hook_bind, reinterpret_cast<LPVOID*>(&pbind));

	// Give me the HWND please maxitune
	MH_CreateHookApi(L"user32", "ShowWindow", Hook_ShowWindow, reinterpret_cast<LPVOID*>(&pShowWindow));
	//MH_CreateHookApi(L"kernel32", "ReadFile", Hook_ReadFile, reinterpret_cast<LPVOID*>(&pReadFile));

	// Hook the window procedure
	// (The image starts at 0x140000000)
	//MH_CreateHook((void*)(imageBase + 0xB7C030), Hook_WndProc, (void**)&pMaxituneWndProc);
	pMaxituneWndProc = (WindowProcedure_t)(imageBase + 0xC69BB0);

	GenerateDongleData(isTerminal);

	injector::WriteMemory<uint8_t>(imageBase + 0x716BC6, 0, true); 	// pls check

	// Skip weird camera init that stucks entire pc on certain brands. TESTED ONLY ON 05!!!!
	if (ToBool(config["General"]["WhiteScreenFix"]))
	{
		injector::WriteMemory<DWORD>(hook::get_pattern("48 8B C4 55 57 41 54 41 55 41 56 48 8D 68 A1 48 81 EC 90 00 00 00 48 C7 45 D7 FE FF FF FF 48 89 58 08 48 89 70 18 45 33 F6 4C 89 75 DF 33 C0 48 89 45 E7", 0), 0x90C3C032, true);
	}

	//injector::MakeNOP(hook::get_pattern("45 33 C0 BA 65 09 00 00 48 8D 4D B0 E8 ? ? ? ? 48 8B 08", 12), 5);

	// First auth error skip
	injector::WriteMemory<BYTE>(imageBase + 0x71839B, 0xEB, true);

	// Best LAN setting by doomertheboomer
	injector::WriteMemory<BYTE>(imageBase + 0xB0EB4A, 0xEB, true); //content router patch
	injector::MakeNOP(imageBase + 0x7084A6, 2, true);

	if (isTerminal)
	{
		//safeJMP(hook::get_pattern("0F B6 41 05 2C 30 3C 09 77 04 0F BE C0 C3 83 C8 FF C3"), ReturnTrue);
		injector::MakeNOP((imageBase + 0x710445), 5);
		safeJMP(hook::get_pattern("8B 01 0F B6 40 78 C3 CC CC CC CC"), ReturnTrue);
	}
	else
	{
		//injector::WriteMemory<WORD>(imageBase + 0x718FA1, 0x00D2, true); // terminal skip (whyyyyyyyyyyyyyyyy)
		// spam thread
		//injector::MakeNOP(hook::get_pattern("74 ? 80 7B 31 00 75 ? 48 8B 43 10 80 78 31 00 75 1A 48 8B D8 48 8B 00 80 78 31 00 75 ? 48 8B D8"), 2); //this should be the terminal on same machine patch
		
		injector::MakeNOP(hook::get_pattern("74 ? 80 7B 31 00 75 ? 48 8B 43 10 80 78 31 00 75 1A 48 8B D8 48 8B 00 80 78 31 00 75 ? 48 8B D8"), 2);
	}

	// Enable all print
	injector::WriteMemory<BYTE>(imageBase + 0x9891B3, 0xEB, true);

	// Dongle crap
	injector::WriteMemory<BYTE>(imageBase + 0x71683A, 0xEB, true);
	injector::WriteMemory<WORD>(imageBase + 0x716978, 0xE990, true);

	// Skip error modals
	injector::MakeNOP(imageBase + 0x7089F4, 2);

	// path fixes
	injector::WriteMemoryRaw(imageBase + 0x1412758, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1412778, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1412798, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14127B8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14127D8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14127F8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1412818, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1412838, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1412858, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1412870, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7388, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C73A0, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C73B8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C73E0, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7408, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7420, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7438, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7448, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7458, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7470, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7488, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C74A8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C74C8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C74D8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C74E8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7500, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7518, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7530, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7548, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7560, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7578, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C7590, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C75A8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14C75C0, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14CFC48, "TP", 2, true); // F:/contents/
	injector::WriteMemoryRaw(imageBase + 0x151F6D0, "TP/contents/", 12, true); // F:contents/
	injector::WriteMemoryRaw(imageBase + 0x151F6E0, "TP/contents/", 12, true);	// G:contents/
	injector::WriteMemoryRaw(imageBase + 0x1575C50, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1575C68, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x15769C8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x15769E0, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x15769F8, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1576A20, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1576A48, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x1576A60, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x15774C0, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x15774E0, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x157699C, "TP", 2, true); // F:/
	injector::WriteMemoryRaw(imageBase + 0x14D2318, "TP", 2, true);
	injector::WriteMemoryRaw(imageBase + 0x14D2B20, "TP", 2, true);

	if (ToBool(config["General"]["SkipMovies"]))
	{
		// Skip movies fuck you wmmt5
		//safeJMP(imageBase + 0xA7D400, ReturnTrue);
	}

	std::string value = config["General"]["CustomName"];
	if (!value.empty())
	{

	}

	// Fix dongle error (can be triggered by various USB hubs, dongles
	injector::MakeNOP(imageBase + 0x993FFF, 2, true);

	// Save story stuff (only 05)
	{
		// skip erasing of temp card data
		//injector::WriteMemory<uint8_t>(imageBase + 0xB2CF33, 0xEB, true);
		// Skip erasing of temp card
		//safeJMP(imageBase + 0x6ADBF0, LoadGameData); //Disabled temporary to stop users copying WMMT6 save to 6R until save works correctly so load has a purpose!!
		//safeJMP(imageBase + 0x6C7270, ReturnTrue);
	}

	MH_EnableHook(MH_ALL_HOOKS);

}, GameID::WMMT6R);
#endif
#pragma optimize("", on)